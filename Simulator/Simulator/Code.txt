#include<iostream>
#include <stdio.h>
#include <queue>
#include <chrono>
#include <time.h>
#include <Windows.h>
using namespace std;

class Process {       // The class

public:             // Access specifier
	int process_id = 0; // Identificador do processo, inteiro sequencial começando em zero. 
	int bt; // Burst time variable
	int art; // Arrival time variable
	int total_time; //  tempo total de execução, aleatório dentro do intervalo (1, 20) segundos.
	string state[3] = { "Ready", "Running", "Terminated" }; // 0 = Ready ; 1 = Running ; 2 = Terminated
	int remaining_time; // Tempo de execução restante em segundos.
	int quantum;

	int randRange(int low, int high) {
		return rand() % (high - low) + low;
	}
};


int main() {

	srand(time(NULL));

	Process process;


	for (int i = 1; i <= 5; i++) {
		int state_id = 0;
		process.total_time = process.randRange(1, 20);
		process.quantum = process.randRange(1, 10);
		process.remaining_time = process.total_time;
		process.process_id = i;
		//cout << "[ P" << process.process_id << " | Status: " << process.state[state_id] << "Tempo estimado para execucao: " << process.total_time << " segundos. \n\n";
		auto start = chrono::system_clock::now();
		state_id++;
		//cout << "Processo: " << process.process_id << " | Status: " << process.state[state_id] << "\n\n";
		int dec = 0;

		while (dec < process.total_time) {
			cout << "[P:" << process.process_id << "| TR: " << process.remaining_time << "s " << "| Q: " << process.quantum << "]" << endl;
			dec++;
			process.remaining_time--;

			if (process.quantum == 0) {
				break;
			}
			process.quantum--;
			Sleep(1000);
			//system("cls");
		}
		auto end = chrono::system_clock::now();
		state_id++;
		cout << "Processo: " << process.process_id << " | Status: " << process.state[state_id] << "\n\n";
		chrono::duration<double> elapsed_seconds = end - start;
		time_t end_time = std::chrono::system_clock::to_time_t(end);
		cout << "Tempo de execucao do processo: " << elapsed_seconds.count() << " segundos. \n\n";

	}
	return 0;
}
___________________________________________________________________________________________________________________________________

class objeto
{
public:
objeto(int,int,int);

};

objeto::objeto(int x, int y, int vida)
{
// apenas para mostrar que os valores foram passados para as instancias...
printf("%d\n\r %d\n\r %d\n\r",x,y,vida);
}

int main(void)
{
int counter;
objeto *inimigos[3];

system("cls");

for ( counter=0; counter < 3 ; counter++ )
inimigos[counter] = new objeto(100,100,3);

delete [] inimigos;

system("pause");
return 0;
}
___________________________________________________________________________________________________________________________________

|-------------------------------------------------------|
|Logica para armazenar para cada processo no array v1.0 |
|-------------------------------------------------------|

for (int i = 0; i < qtd_process; i++) {
		int state_id = 0;
		int total_time = randRange(1, 20);
		int quantum = randRange(1, 10);
		int remaining_time = total_time;
		int process_id = i;
		arrayProcess[i] = new Process(total_time,remaining_time,process_id,quantum);
		if ((total_time == arrayProcess[i]->total_time)
			&&(quantum == arrayProcess[i]->quantum)
			&& (remaining_time == arrayProcess[i]->remaining_time)
			&& (process_id == arrayProcess[i]->process_id)) 
		{
			cout << "P";
			cout << i + 1;
			arrayProcess[i]->showProcess();
			if (i != 4) {
				cout << ", ";
			}
		}
}
___________________________________________________________________________________________________________________________________

|-------------------------------------------------------|
|Logica para armazenar para cada processo no array v1.1 |
|-------------------------------------------------------|

	int qtd_process;

	cout << "Quantidade de processos : ";
	cin >> qtd_process;
	Process* arrayProcess = new Process[qtd_process];


	for (int i = 0; i < qtd_process; i++) {
		int state_id = 0;
		arrayProcess[i].state[state_id];
		arrayProcess[i].total_time = randRange(1, 20);
		arrayProcess[i].quantum = randRange(1, 10);
		arrayProcess[i].remaining_time = arrayProcess[i].total_time;
		arrayProcess[i].process_id = i;
			cout << "P";
			cout << i + 1;
			arrayProcess[i].showProcess();
			if (i != (qtd_process - 1)) {
				cout << ", ";
			}
	}
___________________________________________________________________________________________________________________________________

 #include <iostream>
 using namespace std;
 int main ()
 {
   int numTests;
   cout << "Enter the number of test scores:";
   cin >> numTests;        
   int * iPtr = new int[numTests];           //colocamos um ponteiro no inicio da memória dinâmica

   for (int i = 0; i < numTests; i++) //Podemos preecher o espaço de memória da forma que quisermos
   {
      cout << "Enter test score #" << i + 1 << " : ";
      cin >> iPtr[i];
   }

   for (int i = 0; i < numTests; i++)  //Mostramos o que foi preenchido ...
      cout << "Test score #" << i + 1 << " is "<< iPtr[i] << endl;
   delete iPtr;
   return 0;
 }